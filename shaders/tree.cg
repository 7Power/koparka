//Cg
/* Generated shader for render state 0EBEDF4C:
  AlphaTestAttrib:greater,0
  LightAttrib:on
    render/dlight
    render/cameraNode/cameraGimbal/camera/dlight2
  ShaderAttrib
  TextureAttrib:on default:arch Tex2:arch_ns
  TransparencyAttrib:alpha
*/
void vshader(
	 in float4 vtx_texcoord0 : TEXCOORD0,
	 out float4 l_texcoord0 : TEXCOORD0,
	 in float4 vtx_texcoord1 : TEXCOORD1,
     in float4 vtx_color : COLOR,
	 out float4 l_texcoord1 : TEXCOORD1,
	 uniform float4x4 trans_model_to_view,
     uniform float4 fog,
     uniform float time,
     uniform float4x4 trans_model_to_world,
	 //out float4 l_eye_position : TEXCOORD2,
	 uniform float4x4 tpose_view_to_model,
	 out float4 l_eye_normal : TEXCOORD3,
	 in float4 vtx_normal : TEXCOORD2,
	 in float4 vtx_tangent1 : TEXCOORD3,
	 in float4 vtx_binormal1 : TEXCOORD4,
	 out float4 l_tangent : TEXCOORD4,
	 out float4 l_binormal : TEXCOORD5,
	 float4 vtx_position : POSITION,
	 out float4 l_position : POSITION,
     out float l_fogfactor: TEXCOORD6,
     out float4 l_world_position : TEXCOORD7,
     out float l_isBark: TEXCOORD2,
	 uniform float4x4 mat_modelproj
) {       
     l_world_position = mul(trans_model_to_world, vtx_position);
     l_isBark=step(0.25, vtx_texcoord0.y);     
     float animation =sin(time+l_world_position.x);     
     animation *=sin(0.5*(time+l_world_position.y));
     animation *=l_isBark;
     animation *=distance(vtx_position.xy, float2(0.0,0.0))*0.04;
     float4 vert= float4(vtx_position.xyz+animation, vtx_position.w);
	 l_position = mul(mat_modelproj, vert);
	 //l_eye_position = mul(trans_model_to_view, vtx_position);
	 //l_eye_normal.xyz = mul((float3x3)tpose_view_to_model, vtx_normal.xyz);
     l_eye_normal.xyz = mul((float3x3)tpose_view_to_model, vtx_normal.xyz);
     //l_eye_normal.xyz = vtx_normal.xyz;
	 l_eye_normal.w = 0;
	 l_texcoord0 = vtx_texcoord0;
	 l_texcoord1 = vtx_texcoord1;
	 l_tangent.xyz = mul((float3x3)tpose_view_to_model, vtx_tangent1.xyz);
     //l_tangent.xyz = vtx_tangent1.xyz;
	 l_tangent.w = 0;
	 l_binormal.xyz = mul((float3x3)tpose_view_to_model, -vtx_binormal1.xyz);
     //l_binormal.xyz =vtx_binormal1.xyz;
	 l_binormal.w = 0;     
     float distToCamera =saturate(l_position.z*fog.a-0.5);     
     float distToEdge=saturate(pow(distance(l_world_position.xy, float2(256,256))/256.0, 4.0));
     l_fogfactor=saturate(distToCamera+distToEdge);
     
}

void fshader(
	 //in float4 l_eye_position : TEXCOORD2,
	 in float4 l_eye_normal : TEXCOORD3,
	 uniform sampler2D tex_0,
	 in float4 l_texcoord0 : TEXCOORD0,
	 uniform sampler2D tex_1,
	 in float4 l_texcoord1 : TEXCOORD1,
	 in float3 l_tangent : TEXCOORD4,
	 in float3 l_binormal : TEXCOORD5,
	 uniform float4x4 dlight_dlight0_rel_view,
	 uniform float4 row1_view_to_model,
	 out float4 o_color : COLOR0,
	 uniform float4 attr_color,
     uniform float4 fog,
     uniform float4 ambient,
     in float l_fogfactor : TEXCOORD6,
     in float l_isBark: TEXCOORD2,
    in float4 l_world_position : TEXCOORD7,
	 uniform float4 attr_colorscale
) { //this is a hack for not using clip planes :((    
    if (attr_colorscale.r<0.99)
        {
        if (l_world_position.z<=attr_colorscale.r*200.0)          
            discard;
        }
    else
    {
	 float4 result;
	 // Fetch all textures.
	 float4 tex0 = tex2D(tex_0, l_texcoord0.xy);
	 float4 tex1 = tex2D(tex_1, l_texcoord1.xy);
	 // Translate tangent-space normal in map to view-space.
	 float3 tsnormal = ((float3)tex1 * 2) - 1;
	 l_eye_normal.xyz *= tsnormal.z;
	 l_eye_normal.xyz += l_tangent * tsnormal.x;
	 l_eye_normal.xyz += l_binormal * tsnormal.y;
	 // Correct the surface normal for interpolation effects
	 l_eye_normal.xyz = normalize(l_eye_normal.xyz);
	 // Begin view-space light calculations
	 float ldist,lattenv,langle;
	 float4 lcolor,lspec,lvec,lpoint,latten,ldir,leye,lhalf;
	 float4 tot_diffuse = float4(0,0,0,0);
	 float4 tot_specular = float4(0,0,0,0);
	 float shininess = 50; // no shininess specified, using default
	 // Directional Light 0
	 lcolor = dlight_dlight0_rel_view[0];
	 lspec  = dlight_dlight0_rel_view[1];
	 lvec   = dlight_dlight0_rel_view[2];
     float NdotL=saturate(dot(l_eye_normal.xyz, lvec.xyz));
	 lcolor *=NdotL; 
	 tot_diffuse += lcolor;
	 lhalf = dlight_dlight0_rel_view[3];
	 lspec *= pow(saturate(dot(l_eye_normal.xyz, lhalf.xyz)), shininess);
	 tot_specular += lspec;
	 
	 // Begin view-space light summation
	 result += ambient;
     //result += tot_diffuse;
	 result += tot_diffuse;
     //result +=l_lightmodel*dlight_dlight0_rel_view[0];
     //if (NdotL<0.1)
     result +=l_isBark*dlight_dlight0_rel_view[0]*0.5*step(0.5,1.0-NdotL);        
	 //result = saturate(result);
	 // End view-space light calculations
	 result.a = 1;
	 result.rgba *= tex0.rgba;
	 //result *= attr_colorscale;
	 tot_specular *= tex1.a;
	 result.rgb = result.rgb + tot_specular.rgb;     
	 o_color =lerp(result, fog,l_fogfactor);     
     o_color.a=result.a;
    }
}
